### Что такое RAII

RAII (Resource Acquisition Is Initialization) значит, что при получении какого-либо ресурса, его инициализируют в конструкторе, а, поработав с ним в функции - корректно освобождают в деструкторе. Даже если в коде бросится исключение, то RAII-объект должен корректно уничтожить принадлежащий ему объект.

Кстати, вспомним, что существует три типа гарантии безопасности исключений:

1. Базовая гарантия - при возникновении любого исключения в некотором методе, состояние программы должно оставаться согласованным. Это означает, не только отсутствие утечек ресурсов, но и сохранение инвариантов класса.
2. Строгая гарантия - если при выполнении операции возникает исключение, то это не должно оказать какого-либо влияния на состояние приложения. Другими словами, строгая гарантия исключений обеспечивает транзакционность операций.
3. Гарантия отсутствия исключений - ни при каких обстоятельствах функция не будет генерировать исключения.

### std::shared_ptr

Осуществляет подсчет ссылок. Когда количество ссылок обнулится, хранимый объект уничтожится с помощью `delete`, `delete[]` или переданного в конструкторе `deleter`'а.

Копируемый. Потокобезопасный на методы своего класса при вызовах к разным экземплярам `shared_ptr` (отсюда следует, что счетчик ссылок атомарен), но начинается data race при доступе к одному и тому же экземпляру `shared_ptr` (лечится `std::atomic<std::shared_ptr>`).

В конструкторе тип данных передаваемого указателя должен быть complete-типом.

##### Aliasing constructor
Иногда возникает желание ссылаться с помощью `shared_ptr` на объект и его мемберов.

Наивное решение:

```c++
struct wheel {};
struct vehicle {
    std::array<std::shared_ptr<wheel>, 4> wheels;
};
```

Проблема такого подхода в том, что при удалении `vehicle`, `wheel` остаются живы, пока на них кто-то ссылается.

Можем захотеть такое поведение: пока кто-то ссылается на составную часть объекта, основной объект жив. Для этого можно хранить для них общий счётчик ссылок.

```c++
struct vehicle {
    std::array<wheel, 4> wheels;
}
std::shared_ptr<vehicle> v(new vehicle);
std::shared_ptr<wheel> w(v, &v->wheels[2]);
```

В таком случае оба указателя отвечают за удаление объекта `vehicle` (в зависимости от того, какой из указатель раньше будет разрушен), поэтому `deleter` у них общий, кроме того в управляющем блоке хранится `ptr` на исходный объект, чтобы передать его в `deleter`.

##### std::shared_ptr::owner_before
С помощью этого можно проверять, что смарт-указатели относятся к одному `control block`'у, а не хранят одинаковый указатель, но конкретного определения этого метода я не понял.

##### std::make_shared - зачем?
Потенциально одна аллокация вместо двух + cache-friendly - `control block` и объект, которым владеем, лежат рядышком.

##### std::enable_shared_from_this - зачем?
Посмотрим на следующий код:

```c++
T* p = new T();
std::shared_ptr<T> p1(p);
std::shared_ptr<T> p2(p);
```

Такой код некорректен, так как у `p1` и `p2` разные счётчики ссылок, поэтому объект `*p` удалится дважды. Чтобы этого не происходило, не нужно оборачивать один сырой указатель в `shared_ptr` дважды.

Использование `std::make_shared` или использование `std::enable_shared_from_this` (когда хотим вернуть `shared_ptr(this)`, будем писать `shared_from_this()`) также позволяет избежать разделения счётчика ссылок. Пример:

```cpp
#include <memory>
 
struct Foo : public std::enable_shared_from_this<Foo> {
    Foo() {}  // implicitly calls enable_shared_from_this constructor
    std::shared_ptr<Foo> getFoo() {
		return shared_from_this();
	}
};
 
int main() {
    std::shared_ptr<Foo> pf1(new Foo);
    auto pf2 = pf1->getFoo();  // shares ownership of object with pf1
}
```

### std::weak_ptr

`std::weak_ptr` is a smart pointer that holds a non-owning ("weak") reference to an object that is managed by `std::shared_ptr`. It must be converted to `std::shared_ptr` in order to access the referenced object (to take temporary ownership).

Another use for `std::weak_ptr` is to break reference cycles formed by objects managed by `std::shared_ptr` that leads to memory leak.

Thread-safe as much as `std::shared_ptr`.

### static_pointer_cast, dynamic_pointer_cast, const_pointer_cast, reinterpret_pointer_cast

очевидно :)

### std::unique_ptr

До внедрения в стандарт move-семантики (до С++11) разработчики могли хотеть в языке указатель, следовавший концепции RAII, но не разделяющий владение. Так появился `auto_ptr`.

С приходом C++11 его пришлось пометить как `deprecated`, поскольку его оператор присваивания работал ровным счетом как оператор перемещения сейчас, что могло приводить к непониманию и абсолютно не вписывалось в новые фишки стандарта. Так появился `unique_ptr`.

`unique_ptr` не хранит счетчик ссылок (является полным владельцем переданного ему указателя), конструктор копирования и оператор присваивания у него запрещены, зато его можно мувать.

В отличие от `shared_ptr` этому умному указателю не нужны дополнительные функции для кастования (опять же, потому что он является полным владельцем своего объекта), но ему так же можно настраивать `deleter` и вызывать функцию `std::make_unique()`, подобную таковой у первого указателя.