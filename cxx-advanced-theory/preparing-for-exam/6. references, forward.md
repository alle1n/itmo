### Reference collapsing rule

Еще до С++11 ввели, что ссылка на ссылку - это ссылка без вложенности. В связи с введением `rvalue`-ссылок правило пришлось дополнить.

```
(A&)& -> A&
(A&)&& -> A&
(A&&)& -> A&
(A&&)&& -> A&&
```

Так же в связи с появлением нового типа ссылок стало необходимо распознавать, ссылка какого типа пришла в функцию. Разрабочтики решили даром синтаксис не терять и не городить новых конструкций, поэтому написание `T&&` от шаблонного типа стало означать новую фичу.

### Универсальная ссылка

В C++11 правила вывода шаблонных параметров были определены специальным образом, который позволил сохранить информацию о том, ссылка какого типа в функцию передавалась.

```cpp
template <typename T>
void g(T&& a) {
    f(a);
}

int main {
    g(42); // rvalue: T -> int, void g(int&&)
    int a;
    g(a); // lvalue: T -> int&, void g(int&)
}
```

Здорово, но как ни крути `int&&` - это теперь именованная ссылка, а значит это не `prvalue` и мувать напрямую его нельзя. Как сохранять тип ссылки при передаче аргументов?

### std::forward

Такой синтаксис получила эта техника, ставшая известной под названием `Perfect forwarding`.

```cpp
template <typename T, typename... Tail>
void g(T&& t, Tail&& ...tail) {
    f(std::forward<T>(t), std::forward<Tail>(tail)...);
}
```

